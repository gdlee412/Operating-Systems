# Program and Process

## The fork() system call

-   Create a new process
    -   the newly-created process has its own copy of the `address space`, `registers`, and `PC`
    -   **`IDENTICAL TWIN`**
-   returns PID
    -   to differentiate parent to child
    -   parent returns child's PID
    -   child returns 0
        -   since child doesn't have another child
-   when error happens, system call always return negative value
    -   errno.h

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
    exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else { // parent goes down this path (main)
        printf("hello, I am parent of %d (pid:%d)\n", rc, (int) getpid());
    }
    return 0;
}
```

-   Result (Not deterministic)

```
prompt> ./p1
hello world (pid:29146)
hello, I am parent of 29147 (pid:29146)
hello, I am child (pid:29147)
prompt>
```

-   OR

```
prompt> ./p1
hello world (pid:29146)
hello, I am child (pid:29147)
hello, I am parent of 29147 (pid:29146)
prompt>
```

## The wait() System Call

-   This system call won't return until the child has run and exited

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main(int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else { // parent goes down this path (main)
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
        rc, wc, (int) getpid());
    }
    return 0;
}
```

-   Result (Deterministic)

```
prompt> ./p2
hello world (pid:29266)
hello, I am child (pid:29267)
hello, I am parent of 29267 (wc:29267) (pid:29266)
prompt>
```

-   Defunct: When the child process is killed but the parent process does not use the signal

    -   Thus the data and structure of the child process still exists
    -   Zombie process

-   init()
    -   a fork() without the existence of a parent process

## The exec() System Call

-   Run a program that is different from the parent

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
int main(int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc"); // program: "wc" (word count)
        myargs[1] = strdup("p3.c"); // argument: file to count
        myargs[2] = NULL; // marks end of array
        execvp(myargs[0], myargs); // runs word count
        printf("this shouldn’t print out");
    } else { // parent goes down this path (main)
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
        rc, wc, (int) getpid());
    }
    return 0;
}
```

-   Result

```
prompt> ./p3
hello world (pid:29383)
hello, I am child (pid:29384)
29 107 1030 p3.c
hello, I am parent of 29384 (wc:29384) (pid:29383)
prompt>
```

## How to provide the illusion of many CPUs?

-   CPU virtualizing
    -   The OS can promote the <u>illusion</u> that many virtual CPUs exist
    -   **Time sharing**: Running one process, then stopping it and running another
        -   The potential cost is `performance`
-   야바위
    -   The OS knocks the processes out and gives the authorization(CPU) to the process that is active
    -   OS will then knock out that process, wake up another process, then give the pen(CPU) to another process

## A Process

-   Process is a `program in execution`
    -   program is the existence of code in the disk
-   Comprising of a process:
    -   Memory (address space)
        -   Instructions
        -   Data section
    -   Registers
        -   Program counter
        -   Stack pointer
-   A process is different than a program
    -   Program: Static code and static data
    -   Process: Dynamic instance of code and data
-   Can have multiple process instances of same program
    -   Can have multiple processes of the same program
    -   Example: many users can run "ls" at the same time

### Process API

-   These APIs are available on any modern OS
    -   **Create**
        -   create a new process to run a program
        -   fork()
    -   **Destroy**
        -   Halt a runaway process
        -   kill()
            -   just delivers a signal
    -   **Wait**
        -   wait for a process to stop running
        -   wait()
    -   Miscellaneous Control
        -   some kind of method to suspend a process and then resume it
    -   Status
        -   get some status info about a process

### Process Creation

1. **Load** a program code into <u>memory</u>, into the address space of the process
    - Programs initially reside on disk in _executable format_
    - OS perform the loading process `lazily`
        - Loading pieces of code or data only as they are needed during program execution
2. The program's run-time **stack** is allocated
    - Use the stack for _local variables_, _function parameters_, and _return address_
    - Initialize the stack with arguments -> `argc` and the `argv` array of `main()` function
3. The program's **heap** is created
    - Used for explicitly requested dynamically allocated data
    - Program requests such space by calling `malloc()` and frees it by calling `free()`
4. The OS does some other initialization tasks
    - input/output (I/O) setup
        - Each process by default has three open file descriptors
        - Standard input, output and error (0, 1, 2)
5. **Start the program** running at the entry point, namely `main()`
    - The OS _transfers control_ of the CPU to the newly-created process

### Process States

-   a process is one of three states
    -   **Running**
        -   A process is running on a processor
    -   **Ready**
        -   A process is ready to run but for some reason the OS has chosen not to run it at this given moment
    -   **Blocked**
        -   A process has performed some kind of operation
        -   When a process initiates an I/O request to a disk, it becomes blocked and thus some other process can use the processor

#### Process State Transition

```
Running -> Descheduled -> Ready
Running <- Scheduled <- Ready

Running -> I/O: Initiate -> Blocked

Blocked -> I/O: Done -> Ready
```

### Data Structures

-   The OS has `some key data structures` that track various relevant pieces of information

    -   `Process List`
        -   Ready processes
        -   Blocked processes
        -   Current running process
    -   Register context

-   PCB (Process Control Block)
    -   A C-structure that contains information `about each process`

#### XV6 Kernel Proc Structure

```c
// the registers xv6 will save and restore
// to stop and subsequently restart a process
struct context {
    int eip; // Index pointer register
    int esp; // Stack pointer register
    int ebx; // Called the base register
    int ecx; // Called the counter register
    int edx; // Called the data register
    int esi; // Source index register
    int edi; // Destination index register
    int ebp; // Stack base pointer register
};
// the different states a process can be in
enum proc_state { UNUSED, EMBRYO, SLEEPING, RUNNABLE, RUNNING, ZOMBIE };
// the information xv6 tracks about each process
// including its register context and state
struct proc {
    char *mem; // Start of process memory
    uint sz; // Size of process memory
    char *kstack; // Bottom of kernel stack
    // for this process
    enum proc_state state; // Process state
    int pid; // Process ID
    struct proc *parent; // Parent process
    void *chan; // If non-zero, sleeping on chan
    int killed; // If non-zero, have been killed
    struct file *ofile[NOFILE]; // Open files
    struct inode *cwd; // Current directory
    struct context context; // Switch here to run process
    struct trapframe *tf; // Trap frame for the
    // current interrupt
};
```

## How to efficiently virtualize the CPU with control?

-   OS needs to share the physical CPU by time sharing
-   Issue
    -   Performance: How can we implement virtualization without adding excessive overhead to the system?
    -   Control: How can we run processes efficiently while retaining control over the CPU?

### Direct Execution

-   Just run the program directly on the CPU

| OS                               | Program                       |
| -------------------------------- | ----------------------------- |
| 1. Create entry for process list |                               |
| 2. Allocate memory for program   |                               |
| 3. Load program into memory      |                               |
| 4. Set up stack with argc / argv |                               |
| 5. Clear registers               |                               |
| 6. Execute call main()           |                               |
|                                  | 7. Run main()                 |
|                                  | 8. Execute return from main() |
| 9. Free memory of process        |                               |
| 10. Remove from process list     |                               |
- Without limits on running programs, the OS wouldn't be in control of anything and thus would be "just a library"

#### Problem 1: Restricted Operation
- What if a process wishes to perform some kind of restricted operation such
as …
    - Issuing an I/O request to a disk
    - Gaining access to more system resources such as CPU or memory
- Solution: Using protected control transfer
    - User mode: Applications do not have full access to hardware resources
    - Kernel mode: The OS has access to the full resources of the machine

#### System Call
- Allow the kernel to carefully expose certain key pieces of functionality to user program, such as …
    - Accessing the file system
    - Creating and destroying processes
    - Communicating with other processes
    - Allocating more memory
- **Trap** instruction
    - Jump into the kernel
    - Raise the privilege level to kernel mode
- **Return-from-trap** instruction
    - Return into the calling user program
    - Reduce the privilege level back to user mode

##### Limited Direction Execution Protocol
- OS @ boot (kernel mode)
    - **initialize trap table**

- Hardware
    - remember address of ... syscall handler

- OS @ run (kernel mode)
    - Create entry for process list
    - Allocate memory for program
    - Load program into memory
    - Setup user stack with argv
    - Fill kernel stack with reg/PC
    - **return-from-trap**

- Hardware
    - restore regs from kernel stack
    - move to user mode
    - jump to main

- Program (user mode)
    - Run main()
    - ...
    - Call system
    - trap into OS
- Hardware
    - save regs to kernel stack
    - move to kernel mode
    - jump to trap handler
- OS @ run (kernel mode)
    - Handle trap
    - Do work of syscall
    - **return-from-trap**
- Hardware
    - restore regs from kernel stack
    - move to user mode
    - jump tp PC after trap
- Program (user mode)
    - ...
    - return from main
    - trap (via exit())
- OS @ run (kernel mode)
    - Free memory of process
    - Remove from process list
###### Kernel Stack

- located below the stack in the memory space

- RSP points to user stack
- there's also a pointer pointing to the kernel stack
- the top most of the kernel stack contains the information of the current process
- When completed, the info of the process is saved to the PCB of that process (also the heap), then it is removed from the top of the stack

#### Problem 2: Switching Between Processes
- How can the OS regain control of the CPU so that it can switch between processes?
    - Cooperative Approach: Wait for system calls
    - Non-cooperative Approach: OS takes control

##### Cooperative Approach: Wait for system calls
- Processes ``periodically give up the CPU`` by making **system calls** such as yield
    - OS decides to run some other tasks
    - Application also transfer control to the OS when they do something illegal
        - Divide by 0
        - Try to access memory that it shouldn't be able to access
    - EX) Early versions of the Macintosh OS, the old Xerox Alto system

- <h1>IMPORTANT</h1>
```
A process gets stuck in an infinite loop
    -> caused by a bug
    -> Reboot the machine
```

##### Non-Cooperative Approach: OS Takes Control
- A timer interrupt
    - During the boot sequence, the OS stat the timer
    - The timer raise an *interrupt* every so many milliseconds
    - When the interrupt is raised:
        - The currently running process is halted
        - Save enough of the state of the program
        - A pre-configured interrupt handler in the OS runs
```
Timer interrupt gives OS the ability to run again on a CPU.
```

###### Saving and Restoring Context
- ``Scheduler`` makes a decision:
    - Whether to continue running the **current process**, or switch to a **different one**
    - If the decision is made to switch, the OS executes <u>context switch</u>

###### Context Switch
- Low-level piece of assembly code
    - **Save a few register values** for the current process onto its kernel stack
        - General purpose registers
        - PC
        - kernel stack pointer
    - **Restore a few** for the soon-to-be-executing process from its kernel stack
    - **Switch to the kernel stack** for the soon-to-be-executing process

###### Limited Direction Execution Protocol (Timer interrupt)
- OS @ boot (kernel mode)
    - **initialize trap table**

- Hardware
    - remember address of ... syscall handler
    timer handler

- OS @ boot (kernel mode)
    - **start interrupt timer**

- Hardware
    - start timer
    - interrupt CPU in X ms

- Program (user mode)
    - Process A
    - ...

- Hardware
    - **timer interrupt**
    - save regs(A) to k-stack(A)
    - move to kernel mode
    - jump to trap handler
- OS @ run (kernel mode)
    - Handle the trap
    - Call switch() routine
    - save regs(A) to proc-struct(A)
    - restore regs(B) from proc-struct(B)
    - switch to k-stack(B)
    - **return-from-trap (into B)**
- Hardware
    - restore regs(B) from k-stack(B)
    - move to user mode
    - jump to B's PC
- Program (user mode)
    - Process B
    - ...


##### xv6 COntext Switch Code
```c
# void swtch(struct context *old, struct context *new);
#
# Save current register context in old
# and then load register context from new.
.globl swtch
swtch:
# Save old registers
movl 4(%esp), %eax # put old ptr into eax
popl 0(%eax) # save the old IP
movl %esp, 4(%eax) # and stack
movl %ebx, 8(%eax) # and other registers
movl %ecx, 12(%eax)
movl %edx, 16(%eax)
movl %esi, 20(%eax)
movl %edi, 24(%eax)
movl %ebp, 28(%eax)

# Load new registers
movl 4(%esp), %eax # put new ptr into eax
movl 28(%eax), %ebp # restore other registers
movl 24(%eax), %edi
movl 20(%eax), %esi
movl 16(%eax), %edx
movl 12(%eax), %ecx
movl 8(%eax), %ebx
movl 4(%eax), %esp # stack is switched here
pushl 0(%eax) # return addr put in place
ret # finally return into new ctxt
```
- eax - context starting address pointer

##### Worried about concurrency?
- What happens if, during interrupt or trap handling, another interrupt occurs?
- OS handles these situations:
    - **Disable interrupts** during interrupt processing
    - Use a number of sophisticate **locking** schemes to protect concurrent access to internal data structures