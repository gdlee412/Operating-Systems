# OS

## Software Stack

-   OS is a software that converts hardware into a useful form for applications

## What happens when a program runs?

-   a running program executes instructions
    -   processor fetches an instruction from memory
    -   decode: figure out which instruction this is
    -   Execute: i.e., add two numbers, access memory, check a condition, jump to function, and so forth
    -   The processor moves on to the next instruction and so on
-   Who did load this program into memory?
-   Who does remove this program when this program acts abnormally?

## What happens when many programs run together?

-   Two programs share a single main memory
    -   Program A may corrupt data of program B
    -   How can I tell where my data are located at?
-   Two programs share a small set of processors
    -   when the numver of cores is smaller than the number of running programs, who controls which program uses a processor?
    -   Who decides which program runs on which core?
    -   You have only one mouse and one keyboard, how can multiple programs share the resources?
-   If a program tries to steal your information, which is stored by Chrome web browser, who protects your information from it?

## Operating System (OS)

-   Responsible for
    -   Making it easy to **run** programs
    -   Allowing programs to **share** memory
    -   Enabling programs to **interact** with devices
-   OS is in charge of making sure the system operates `correctly` and `efficiently`

## Three Pieces

-   Virtualization
    -   Make each application believe it has each resource to itself
        -   Processes, CPU scheduling, virtual memory
-   Concurrency
    -   Handle concurrent events correctly
        -   Threads, synchronization
-   Persistence
    -   Access information permanently while preserving correctness upon unexpected failures
        -   Storage, file systems

## Virtualization

-   OS takes `a physical resource` and transforms it into a `virtual form` of itself
    -   Physical resource: Processor, Memory, Disk...
    -   The virtual form is more <u>general</u>, <u>powerful</u>, <u>easy-to-use</u>
    -   Sometimes, we refer to the OS as a `virtual machine`
-   An application cannot directly access (or see) the underlying hardware
    -   An application sees and uses virtualized hardware
    -   An OS is located in between an application and hardware, and acts like an intermediary

## Roles of OS

-   `Resource allocator`
    -   Manages all resources
    -   Decides between conflicting requests for efficient and fair use
-   `Control program`
    -   Controls execution of programs to errors and improper use of the computer

## System Calls

-   allows a program to **request OS what it wants to do**
    -   Systems are interface between OS and applications
    -   A typical OS exports a few hundred system calls
        -   Run programs
        -   Access memory
        -   Access devices

## System Calls (Part 2)

-   Two modes of the OS

    -   User mode (space)
    -   Kernel mode (space)
        -   the core of OS

-   Privileged Instructions

    -   Only available in kernel mode
    -   read disc, write, etc.

-   Exception
    -   CPU stops its process and jumps to the specific register
    -   Exception handlers are saved into register during the os boot
-   Interrupt

    -   An exception caused by outer factors (keyboard inputs)

-   System call

    -   when moved to assembly, the instruction uses `sysenter`
    -   There is a table for all system calls
    -   This exists in the **system call interface** within the kernel space
    -   The `sysenter` will call a specific number value of the table and jump to that table value

-   System call interface

    -   When C uses a function, this function jumps to the standard C library, which allows us to enter kernel mode where system calls occur

-   Sysexit: instruction to switch mode from kernel back to user mode

-   trap: mechanism in which the user-level program requests a service from the OS kernel and transitions into a privileged execution mode

## Virtualizing CPU

-   System has a very large number of virtual CPUs
-   Turning a single CPU into a <u>seemingly infinite number</u> of CPUs
-   Allowing many programs to <u>seemingly run at once</u>
    -   `Virtualizing the CPU`

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit(1);
    }
    char *str = argv[1];
    while (1) {
        Spin(1); // Repeatedly checks the time and returns once it has run for a second
        printf("%s\n", str);
    }
    return 0;
}
```

-   Execution result

```
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
ˆC
prompt>
```

-   Run forever; Only be pressing "Ctrl-C" can we halt the program

-   Execution result

```
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```

**Even though we have only `one processor`, all four of the programs seem to be running `at the same time`!**

## Differenciating functions

-   man
    -   manual of the UNIX code
    -   consists of 1 - 7
-   man func(2)
    -   System calls
-   man func(3)
    -   library calls

## Virtualizing Memory

-   physical memory is _<u>an array of bytes</u>_
-   A program keeps all of its data structures in memory
    -   **Read memory** (load):
        -   Specify an <u>address</u> to be able to access the data
    -   **Write memory** (store):
        -   Specify the data to be written to the given address
-   Let's read a program that accesses memory (mem.c)

```c
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

int main(int argc, char *argv[])
{
    int *p = malloc(sizeof(int)); // a1: allocate memory
    assert(p != NULL);
    printf("(%d) address of p: %08x\n",
        getpid(), (unsigned) p); // a2: print out the address of the memmory
    *p = 0; // a3: put zero into the first slot of the memory
    while (1) {
        Spin(1);
        *p = *p + 1;
        printf("(%d) p: %d\n", getpid(), *p); // a4
    }
    return 0;
}
```

-   The output of the program mem.c

```
prompt> ./mem
(2134) memory address of p: 00200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC
```

-   The newly allocated memory is at address 00200000.
-   It updates the value and prints out the result

-   Running mem.c multiple times

```
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000
(24114) memory address of p: 00200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
...
```

-   It is as if each running program has its **own private memory**.

    -   Each running program has allocated memory at <u>the same address</u>
    -   Each seems to be updating the value at 00200000 independently

-   Each process accesses its own private `virtual address space`
    -   The OS maps ``address space`` onto the ``physical memory``
    - A memory reference within one running program <u>does not affect</u> the address space of other processes
    - Physical memory is a <u>shared resource</u>, managed by the OS

## Problem of Concurrency
- The OS is juggling `many things at once`, first running one process, then another, and so forth
- Modern `multi-threaded programs` also exhibit the concurrency problem

### Stack Addres Space
- text
- data
- heap
- ...
- stack

#### Multithreads in stack
- Each thread addresses to one stack within the stack address space
- Uses Time sharing concept to act as if there are several pc registers

### Concurrency Example
```c
#include <stdio.h>
#include <stdlib.h>
#include "common.h"

volatile int counter = 0;
int loops;

void *worker(void *arg) {
    int i;
    for (i = 0; i < loops; i++) {
            counter++;
        }
    return NULL;
}

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: threads <value>\n");
        exit(1);
    }
    loops = atoi(argv[1]);
    pthread_t p1, p2;
    printf("Initial value : %d\n", counter);

    Pthread_create(&p1, NULL, worker, NULL);
    Pthread_create(&p2, NULL, worker, NULL);
    Pthread_join(p1, NULL);
    Pthread_join(p2, NULL);
    printf("Final value : %d\n", counter);
    return 0;
}
```
- The main program creates **two threads**
    - `Threads`: a function running within the same memory space. Each thread start running in a routine called ``worker()``
    - ``worker()``: increments a counter

- `loops`: determines how many times each of the two workers will **increment the shared counter** in a loop

- loops: 1000
```
prompt> gcc -o thread thread.c -Wall -pthread
prompt> ./thread 1000
Initial value : 0
Final value : 2000
```

- loops: 100000
```
prompt> ./thread 100000
Initial value : 0
Final value : 143012 // huh??
prompt> ./thread 100000
Initial value : 0
Final value : 137298 // what the??
```

#### Why?
- Increment a shared counter -> take three instructions
    1. Load the value of the counter from memory into register
    2. Increment it
    3. Store it back into memory
- These three instructions do not execute `atomically` -> Problem of **concurrency** happen

## Persistence
- Devices such as DRMA store values in a <u>volatile</u>
- *Hardware* and *software* are needed to store data `persistently`
    - **Hardware**: I/O device such as a hard drive, solid-state drived(SSDs)
    - **Software**:
        - File system manages the disk
        - File system is responsible for <u>storing any files</u> the user creates

### Persistence Example
- create a file (/tmp/file) that countains the string "hello world"

```c
#include <stdio.h>
#include <unistd.h>
#include <assert.h>
#include <fcntl.h>
#include <sys/types.h>

int main(int argc, char *argv[])
{
    int fd = open("/tmp/file", O_WRONLY | O_CREAT | O_TRUNC, S_IRWXU);
    assert(fd > -1);
    int rc = write(fd, "hello world\n", 13);
    assert(rc == 13);
    close(fd);
    return 0;
}
```
- open(), write(), and close() system calls are routed to the part of OS and called the file system, which handles the requests

### Persistence (continued)
- a disk, like main memory, is just a large array of bytes
- What OS does in order to write data to disk and manage them?
    - Figure out **where** on disk this new data will reside
    - **Issue I/O** requests to the underlying storage device
- File system handles system crashes during write
    - **Journaling** or **copy-on-write**
    - Carefully <u>ordering</u> writes to disk

### Design Goals
- Build up **abstraction**
    - Make the system convenient and easy to use
    - not too much abstraction
        - becomes easier to write, but harder to maintain
- Provide high **performance**
    - Minimize the overhead of the OS
    - OS must strive to provide virtualization <u>without excessive overhead</u>
- **Protection** between applications
    - <u>Isolation</u>: Bad behavior of one does not harm other and the OS itself
- High degree of **reliability**
    - The OS must also run non-stop
- Other issues
    - Energy-efficiency
    - Security
    - Mobility