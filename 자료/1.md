# OS

## Software Stack
- OS is a software that converts hardware into a useful form for applications

## What happens when a program runs?
- a running program executes instructions
    - processor fetches an instruction from memory
    - decode: figure out which instruction this is
    - Execute: i.e., add two numbers, access memory, check a condition, jump to function, and so forth
    - The processor moves on to the next instruction and so on
- Who did load this program into memory?
- Who does remove this program when this program acts abnormally?

## What happens when many programs run together?
- Two programs share a single main memory
    - Program A may corrupt data of program B
    - How can I tell where my data are located at?
- Two programs share a small set of processors
    - when the numver of cores is smaller than the number of running programs, who controls which program uses a processor?
    - Who decides which program runs on which core?
    - You have only one mouse and one keyboard, how can multiple programs share the resources?
- If a program tries to steal your information, which is stored by Chrome web browser, who protects your information from it?

## Operating System (OS)
- Responsible for
    - Making it easy to **run** programs
    - Allowing programs to **share** memory
    - Enabling programs to **interact** with devices
- OS is in charge of making sure the system operates ``correctly`` and ``efficiently``

## Three Pieces
- Virtualization
    - Make each application believe it has each resource to itself
        - Processes, CPU scheduling, virtual memory
- Concurrency
    - Handle concurrent events correctly
        - Threads, synchronization
- Persistence
    - Access information permanently while preserving correctness upon unexpected failures
        - Storage, file systems

## Virtualization
- OS takes ``a physical resource`` and transforms it into a ``virtual form`` of itself
    - Physical resource: Processor, Memory, Disk...
    - The virtual form is more <u>general</u>, <u>powerful</u>, <u>easy-to-use</u>
    - Sometimes, we refer to the OS as a ``virtual machine``
- An application cannot directly access (or see) the underlying hardware
    - An application sees and uses virtualized hardware
    - An OS is located in between an application and hardware, and acts like an intermediary

## Roles of OS
- ``Resource allocator``
    - Manages all resources
    - Decides between conflicting requests for efficient and fair use
- ``Control program``
    - Controls execution of programs to errors and improper use of the computer

## System Calls
- allows a program to **request OS what it wants to do**
    - Systems are interface between OS and applications
    - A typical OS exports a few hundred system calls
        - Run programs
        - Access memory
        - Access devices

## System Calls (Part 2)
- Two modes of the OS
    - User mode (space)
    - Kernel mode (space)
        - the core of OS

- Privileged Instructions
    - Only available in kernel mode
    - read disc, write, etc.

- Exception
    - CPU stops its process and jumps to the specific register
    - Exception handlers are saved into register during the os boot
- Interrupt
    - An exception caused by outer factors (keyboard inputs)

- System call
    - when moved to assembly, the instruction uses ``sysenter``
    - There is a table for all system calls
    - This exists in the **system call interface** within the kernel space
    - The ``sysenter`` will call a specific number value of the table and jump to that table value

- System call interface
    - When C uses a function, this function jumps to the standard C library, which allows us to enter kernel mode where system calls occur

- Sysexit: instruction to switch mode from kernel back to user mode

- trap: mechanism in which the user-level program requests a service from the OS kernel and transitions into a privileged execution mode
 
## Virtualizing CPU
- System has a very large number of virtual CPUs
- Turning a single CPU into a <u>seemingly infinite number</u> of CPUs
- Allowing many programs to <u>seemingly run at once</u>
    - ``Virtualizing the CPU``

```c
#include <stdio.h>
#include <stdlib.h>
#include <sys/time.h>
#include <assert.h>
#include "common.h"

int main(int argc, char *argv[])
{
    if (argc != 2) {
        fprintf(stderr, "usage: cpu <string>\n");
        exit(1);
    }
    char *str = argv[1];
    while (1) {
        Spin(1); // Repeatedly checks the time and returns once it has run for a second
        printf("%s\n", str);
    }
    return 0;
}
```

- Execution result
```
prompt> gcc -o cpu cpu.c -Wall
prompt> ./cpu "A"
A
A
A
ˆC
prompt>
```
- Run forever; Only be pressing "Ctrl-C" can we halt the program


- Execution result
```
prompt> ./cpu A & ; ./cpu B & ; ./cpu C & ; ./cpu D &
[1] 7353
[2] 7354
[3] 7355
[4] 7356
A
B
D
C
A
B
D
C
A
C
B
D
...
```
**Even though we have only ``one processor``, all four of the programs seem to be running ``at the same time``!**

## Differenciating functions
- man
    - manual of the UNIX code
    - consists of 1 - 7
- man func(2)
    - System calls
- man func(3)
    - library calls

## Virtualizing Memory
- physical memory is *<u>an array of bytes</u>*
- A program keeps all of its data structures in memory
    - **Read memory** (load):
        - Specify an <u>address</u> to be able to access the data
    - **Write memory** (store):
        - Specify the data to be written to the given address
- Let's read a program that accesses memory (mem.c)

```c
#include <unistd.h>
2 #include <stdio.h>
3 #include <stdlib.h>
4 #include "common.h"
5
6 int
7 main(int argc, char *argv[])
8 {
9 int *p = malloc(sizeof(int)); // a1: allocate memory
10 assert(p != NULL);
11 printf("(%d) address of p: %08x\n",
12 getpid(), (unsigned) p); // a2: print out the
address of the memmory
13 *p = 0; // a3: put zero into the first slot of the memory
14 while (1) {
15 Spin(1);
16 *p = *p + 1;
17 printf("(%d) p: %d\n", getpid(), *p); // a4
18 }
19 return 0;
20 }
```

- The output of the program mem.c
```
prompt> ./mem
(2134) memory address of p: 00200000
(2134) p: 1
(2134) p: 2
(2134) p: 3
(2134) p: 4
(2134) p: 5
ˆC
```
- The newly allocated memory is at address 00200000.
- It updates the value and prints out the result

- Running mem.c multiple times
```
prompt> ./mem &; ./mem &
[1] 24113
[2] 24114
(24113) memory address of p: 00200000
(24114) memory address of p: 00200000
(24113) p: 1
(24114) p: 1
(24114) p: 2
(24113) p: 2
(24113) p: 3
(24114) p: 3
...
```

- It is as if each running program has its **own private memory**.
    - Each running program has allocated memory at <u>the same address</u>
    - Each seems to be updating the value at 00200000 independently