# Program and Process

## The fork() system call

-   Create a new process
    -   the newly-created process has its own copy of the `address space`, `registers`, and `PC`
    -   **`IDENTICAL TWIN`**
-   returns PID
    -   to differentiate parent to child
    -   parent returns child's PID
    -   child returns 0
        -   since child doesn't have another child
-   when error happens, system call always return negative value
    -   errno.h

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
int main(int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
    exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else { // parent goes down this path (main)
        printf("hello, I am parent of %d (pid:%d)\n", rc, (int) getpid());
    }
    return 0;
}
```

-   Result (Not deterministic)

```
prompt> ./p1
hello world (pid:29146)
hello, I am parent of 29147 (pid:29146)
hello, I am child (pid:29147)
prompt>
```

-   OR

```
prompt> ./p1
hello world (pid:29146)
hello, I am child (pid:29147)
hello, I am parent of 29147 (pid:29146)
prompt>
```

## The wait() System Call

-   This system call won't return until the child has run and exited

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/wait.h>
int main(int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
    } else { // parent goes down this path (main)
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
        rc, wc, (int) getpid());
    }
    return 0;
}
```

-   Result (Deterministic)

```
prompt> ./p2
hello world (pid:29266)
hello, I am child (pid:29267)
hello, I am parent of 29267 (wc:29267) (pid:29266)
prompt>
```
- Defunct: When the child process is killed but the parent process does not use the signal
    - Thus the data and structure of the child process still exists
    - Zombie process

- init()
    - a fork() without the existence of a parent process

## The exec() System Call

-   Run a program that is different from the parent

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <sys/wait.h>
int main(int argc, char *argv[]){
    printf("hello world (pid:%d)\n", (int) getpid());
    int rc = fork();
    if (rc < 0) { // fork failed; exit
        fprintf(stderr, "fork failed\n");
        exit(1);
    } else if (rc == 0) { // child (new process)
        printf("hello, I am child (pid:%d)\n", (int) getpid());
        char *myargs[3];
        myargs[0] = strdup("wc"); // program: "wc" (word count)
        myargs[1] = strdup("p3.c"); // argument: file to count
        myargs[2] = NULL; // marks end of array
        execvp(myargs[0], myargs); // runs word count
        printf("this shouldn’t print out");
    } else { // parent goes down this path (main)
        int wc = wait(NULL);
        printf("hello, I am parent of %d (wc:%d) (pid:%d)\n",
        rc, wc, (int) getpid());
    }
    return 0;
}
```
- Result
```
prompt> ./p3
hello world (pid:29383)
hello, I am child (pid:29384)
29 107 1030 p3.c
hello, I am parent of 29384 (wc:29384) (pid:29383)
prompt>
```

## How to provide the illusion of many CPUs?
- CPU virtualizing
    - The OS can promote the <u>illusion</u> that many virtual CPUs exist
    - **Time sharing**: Running one process, then stopping it and running another
        - The potential cost is `performance`
- 야바위
    - The OS knocks the processes out and gives the authorization(CPU) to the process that is active
    - OS will then knock out that process, wake up another process, then give the pen(CPU) to another process

## A Process
- Process is a `program in execution`
    - program is the existence of code in the disk
- Comprising of a process:
    - Memory (address space)
        - Instructions
        - Data section
    - Registers
        - Program counter
        - Stack pointer
- A process is different than a program
    - Program: Static code and static data
    - Process: Dynamic instance of code and data
- Can have multiple process instances of same program
    - Can have multiple processes of the same program
    - Example: many users can run "ls" at the same time

### Process API
- These APIs are available on any modern OS
    - **Create**
        - create a new process to run a program
        - fork()
    - **Destroy**
        - Halt a runaway process
        - kill()
            - just delivers a signal
    - **Wait**
        - wait for a process to stop running
        - wait()
    - Miscellaneous Control
        - some kind of method to suspend a process and then resume it
    - Status
        - get some status info about a process

### Process Creation
1. **Load** a program code into <u>memory</u>, into the address space of the process
    - Programs initially reside on disk in *executable format*
    - OS perform the loading process `lazily`
        - Loading pieces of code or data only as they are needed during program execution
2. The program's run-time **stack** is allocated
    - Use the stack for *local variables*, *function parameters*, and *return address*
    - Initialize the stack with arguments -> `argc` and the `argv` array of `main()` function
3. The program's **heap** is created
    - Used for explicitly requested dynamically allocated data
    - Program requests such space by calling `malloc()` and frees it by calling `free()`
4. The OS does some other initialization tasks
    - input/output (I/O) setup
        - Each process by default has three open file descriptors
        - Standard input, output and error (0, 1, 2)
5. **Start the program** running at the entry point, namely `main()`
    - The OS *transfers control* of the CPU to the newly-created process

### Process States
- a process is one of three states
    - **Running**
        - A process is running on a processor
    - **Ready**
        - A process is ready to run but for some reason the OS has chosen not to run it at this given moment
    - **Blocked**
        - A process has performed some kind of operation
        - When a process initiates an I/O request to a disk, it becomes blocked and thus some other process can use the processor